<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Encontre a Bolinha</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; touch-action: none; }

        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #ccc;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 1px;
            z-index: 10;
        }

        #level-info {
            position: absolute;
            top: 50px;
            width: 100%;
            text-align: center;
            color: #4db8ff;
            pointer-events: none;
            font-size: 16px;
            z-index: 10;
        }

        #victory-overlay {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: #4db8ff;
            padding: 40px;
            border-radius: 20px;
            font-size: 48px;
            font-weight: bold;
            text-align: center;
            z-index: 100;
            border: 4px solid #4db8ff;
            box-shadow: 0 0 20px #4db8ff;
            pointer-events: none;
        }

        /* Estilização dos Botões Touch (Mobile) */
        .touch-btn {
            position: absolute;
            bottom: 40px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
            text-align: center;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            z-index: 20;
            backdrop-filter: blur(5px);
        }

        .touch-btn:active, .touch-btn.active {
            background: rgba(77, 184, 255, 0.6);
            scale: 0.95;
            border-color: #4db8ff;
        }

        #btn-grab { left: 30px; }
        #btn-cut { left: 50%; transform: translateX(-50%); }
        #btn-rotate { right: 30px; }

        b { color: #4db8ff; }
    </style>
</head>
<body>

    <div id="info">Encontre a bolinha escondida sob os objetos! Arraste-os para o lado.</div>
    <div id="level-info">Fase 1</div>
    <div id="victory-overlay">VITÓRIA!</div>

    <!-- Botão Virtual (Mobile) -->
    <div id="btn-grab" class="touch-btn active">AGARRAR</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- OTIMIZAÇÃO: Configurações de Física ---
        const DAMPING = 0.97;
        const MASS = 0.1; // Aumentei um pouco a massa para compensar menos partículas
        const GRAVITY = 981 * 1.2;
        const TIMESTEP = 18 / 1000;

        // OTIMIZAÇÃO 1: Redução drástica da resolução (de 100x100 para 50x50)
        // Isso reduz de 10.000 para 2.500 partículas (4x mais rápido)
        const xSegs = 50; 
        const ySegs = 50;
        // Compensamos a distância para manter o tamanho original do tecido
        // (Antes era 4.5 * 100 = 450 largura. Agora 9 * 50 = 450 largura)
        const restDistance = 9.0; 

        let simulationObjects = [];
        let targetBall = null;
        let currentLevel = 0;
        const levelConfigs = [
            { type: 'cloth', count: 5, info: "Fase 1: Tecidos" },
            { type: 'box', count: 8, info: "Fase 2: Cubos" },
            { type: 'ball', count: 12, info: "Fase 3: Bolinhas" },
            { type: 'mixed', count: 15, info: "Fase 4: Mistura" },
            { type: 'mixed', count: 25, info: "Fase 5: Caos" },
            { type: 'mixed', count: 40, info: "Fase Final: Onde está?" }
        ];
        let camera, scene, renderer, controls;
        let isDragging = false;
        let mousePos = new THREE.Vector2();
        let prevMousePos = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        let draggedParticle = null;
        let activeMode = 'grab';

        const tmpVec = new THREE.Vector3();
        const _v3 = new THREE.Vector3();
        const forceGravity = new THREE.Vector3();
        let projectedPositions = [];

        // --- Classes de Física Otimizadas ---

        class Particle {
            constructor(x, y, z, mass) {
                this.position = new THREE.Vector3(x, y, z);
                this.previous = new THREE.Vector3(x, y, z);
                this.a = new THREE.Vector3(0, 0, 0);
                this.invMass = 1 / mass;
                this.tmp = new THREE.Vector3();
            }

            addForce(force) {
                if (this.invMass > 0) {
                    tmpVec.copy(force).multiplyScalar(this.invMass);
                    this.a.add(tmpVec);
                }
            }

            integrate(timesq) {
                if (this.invMass === 0) return;
                const newPos = this.tmp.subVectors(this.position, this.previous);
                newPos.multiplyScalar(DAMPING).add(this.position);
                tmpVec.copy(this.a).multiplyScalar(timesq);
                newPos.add(tmpVec);
                this.previous.copy(this.position);
                this.position.copy(newPos);
                this.a.set(0, 0, 0);
            }
        }

        class Constraint {
            constructor(p1, p2, dist) {
                this.p1 = p1;
                this.p2 = p2;
                this.length = dist;
            }

            satisfy() {
                tmpVec.subVectors(this.p2.position, this.p1.position);
                const currentDist = tmpVec.length();
                if (currentDist === 0) return;
                const correction = (1 - this.length / currentDist) * 0.5;
                tmpVec.multiplyScalar(correction);
                if (this.p1.invMass !== 0) this.p1.position.add(tmpVec);
                if (this.p2.invMass !== 0) this.p2.position.sub(tmpVec);
            }
        }

        class SimulationObject {
            constructor() {
                this.particles = [];
                this.constraints = [];
                this.mesh = null;
            }
            updateMesh() {}
            dispose() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    if (this.mesh.geometry) this.mesh.geometry.dispose();
                    if (this.mesh.material) this.mesh.material.dispose();
                }
            }
        }

        class ClothObject extends SimulationObject {
            constructor(x, y, z, color) {
                super();
                const localXSegs = 20;
                const localYSegs = 20;
                const localRestDist = 12.0;

                const index = (u, v) => u + v * (localXSegs + 1);

                for (let v = 0; v <= localYSegs; v++) {
                    for (let u = 0; u <= localXSegs; u++) {
                        const p = new Particle(
                            x + (u - localXSegs/2) * localRestDist,
                            y + (localYSegs/2 - v) * localRestDist,
                            z + (Math.random() - 0.5) * 2,
                            MASS
                        );
                        this.particles.push(p);
                    }
                }

                for (let v = 0; v <= localYSegs; v++) {
                    for (let u = 0; u <= localXSegs; u++) {
                        if (u < localXSegs) this.constraints.push(new Constraint(this.particles[index(u, v)], this.particles[index(u + 1, v)], localRestDist));
                        if (v < localYSegs) this.constraints.push(new Constraint(this.particles[index(u, v)], this.particles[index(u, v + 1)], localRestDist));
                    }
                }

                const geo = new THREE.PlaneGeometry(1, 1, localXSegs, localYSegs);
                const mat = new THREE.MeshStandardMaterial({ color, side: THREE.DoubleSide });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                scene.add(this.mesh);
            }

            updateMesh() {
                const posAttr = this.mesh.geometry.attributes.position;
                for (let i = 0; i < this.particles.length; i++) {
                    posAttr.setXYZ(i, this.particles[i].position.x, this.particles[i].position.y, this.particles[i].position.z);
                }
                posAttr.needsUpdate = true;
                this.mesh.geometry.computeVertexNormals();
            }
        }

        class BoxObject extends SimulationObject {
            constructor(x, y, z, size, color) {
                super();
                const half = size / 2;
                const corners = [
                    [-half, -half, -half], [half, -half, -half], [half, half, -half], [-half, half, -half],
                    [-half, -half, half], [half, -half, half], [half, half, half], [-half, half, half]
                ];
                for (let c of corners) {
                    this.particles.push(new Particle(x + c[0], y + c[1], z + c[2], MASS));
                }

                const addC = (i, j) => {
                    const d = this.particles[i].position.distanceTo(this.particles[j].position);
                    this.constraints.push(new Constraint(this.particles[i], this.particles[j], d));
                };

                // Edges
                for (let i = 0; i < 4; i++) {
                    addC(i, (i + 1) % 4);
                    addC(i + 4, ((i + 1) % 4) + 4);
                    addC(i, i + 4);
                }
                // Diagonals for stability
                addC(0, 2); addC(1, 3); addC(4, 6); addC(5, 7);
                addC(0, 5); addC(1, 4); addC(2, 7); addC(3, 6);
                addC(0, 6); addC(1, 7); addC(2, 4); addC(3, 5);

                this.mesh = new THREE.Mesh(new THREE.BoxGeometry(size, size, size), new THREE.MeshStandardMaterial({ color }));
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                scene.add(this.mesh);
            }

            updateMesh() {
                const center = new THREE.Vector3();
                for (let p of this.particles) center.add(p.position);
                center.divideScalar(8);
                this.mesh.position.copy(center);

                // Calculate rotation based on particles
                const xAxis = new THREE.Vector3().subVectors(this.particles[1].position, this.particles[0].position).normalize();
                const yAxis = new THREE.Vector3().subVectors(this.particles[3].position, this.particles[0].position).normalize();
                const zAxis = new THREE.Vector3().crossVectors(xAxis, yAxis).normalize();
                const orthoYAxis = new THREE.Vector3().crossVectors(zAxis, xAxis).normalize();

                const matrix = new THREE.Matrix4();
                matrix.makeBasis(xAxis, orthoYAxis, zAxis);
                this.mesh.quaternion.setFromRotationMatrix(matrix);
            }
        }

        class BallObject extends SimulationObject {
            constructor(x, y, z, radius, color) {
                super();
                this.radius = radius;
                this.particles.push(new Particle(x, y, z, MASS));
                this.mesh = new THREE.Mesh(new THREE.SphereGeometry(radius, 16, 16), new THREE.MeshStandardMaterial({ color }));
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                scene.add(this.mesh);
            }

            updateMesh() {
                this.mesh.position.copy(this.particles[0].position);
            }
        }

        // --- Inicialização ---

        init();
        loadLevel(0);
        animate();

        function loadLevel(index) {
            // Cleanup
            for (let obj of simulationObjects) {
                obj.dispose();
            }
            simulationObjects = [];
            if (targetBall) {
                scene.remove(targetBall);
                targetBall.geometry.dispose();
                targetBall.material.dispose();
                targetBall = null;
            }

            const config = levelConfigs[index % levelConfigs.length];
            document.getElementById('level-info').innerText = config.info;

            // Spawn Target Ball at random position
            const tx = (Math.random() - 0.5) * 400;
            const tz = (Math.random() - 0.5) * 400;
            const ty = -70; // Close to floor

            const targetGeo = new THREE.SphereGeometry(15, 32, 32);
            const targetMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 }); // Gold
            targetBall = new THREE.Mesh(targetGeo, targetMat);
            targetBall.position.set(tx, ty, tz);
            targetBall.castShadow = true;
            targetBall.receiveShadow = true;
            scene.add(targetBall);

            // Spawn Obstacles covering the target
            for (let i = 0; i < config.count; i++) {
                const ox = tx + (Math.random() - 0.5) * 150;
                const oz = tz + (Math.random() - 0.5) * 150;
                const oy = ty + 50 + i * 30;
                const color = new THREE.Color().setHSL(Math.random(), 0.7, 0.5);

                let type = config.type;
                if (type === 'mixed') {
                    const r = Math.random();
                    if (r < 0.33) type = 'cloth';
                    else if (r < 0.66) type = 'box';
                    else type = 'ball';
                }

                let obj;
                if (type === 'cloth') {
                    obj = new ClothObject(ox, oy, oz, color);
                } else if (type === 'box') {
                    obj = new BoxObject(ox, oy, oz, 40 + Math.random() * 20, color);
                } else if (type === 'ball') {
                    obj = new BallObject(ox, oy, oz, 25 + Math.random() * 10, color);
                }
                simulationObjects.push(obj);
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);

            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.set(0, 50, 1100);

            scene.add(new THREE.AmbientLight(0x666666));
            const spotlight = new THREE.SpotLight(0xffffff, 2000000);
            spotlight.position.set(200, 600, 500);
            spotlight.castShadow = true;
            // OTIMIZAÇÃO: Sombra reduzida para 1024 (era 2048)
            spotlight.shadow.mapSize.width = 1024;
            spotlight.shadow.mapSize.height = 1024;
            scene.add(spotlight);

            const fillLight = new THREE.DirectionalLight(0x444455, 1);
            fillLight.position.set(-200, 200, -200);
            scene.add(fillLight);

            const roomSize = 1200;
            const floorGeo = new THREE.PlaneGeometry(roomSize, roomSize);
            const floorMat = new THREE.MeshPhongMaterial({ color: 0x101010 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -100;
            floor.receiveShadow = true;
            scene.add(floor);

            // Walls
            const wallMat = new THREE.MeshPhongMaterial({ color: 0x050505, side: THREE.BackSide });
            const wallGeo = new THREE.BoxGeometry(roomSize, 1200, roomSize);
            const room = new THREE.Mesh(wallGeo, wallMat);
            room.position.y = 500;
            room.receiveShadow = true;
            scene.add(room);

            // Visual boundaries (wireframe)
            const wireframe = new THREE.BoxHelper(room, 0x444444);
            scene.add(wireframe);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            controls.mouseButtons = {
                LEFT: null,
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.ROTATE
            };
            controls.touches = {
                ONE: null,
                TWO: THREE.TOUCH.DOLLY_PAN
            };

            window.addEventListener('resize', onWindowResize);

            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            renderer.domElement.addEventListener('pointermove', onPointerMove);
            window.addEventListener('pointerup', onPointerUp);

            const btnGrab = document.getElementById('btn-grab');

            btnGrab.addEventListener('pointerdown', (e) => {
                e.stopPropagation();
                activeMode = 'grab';
                controls.enabled = false;
            });
        }


        function onPointerDown(event) {
            if (event.pointerType === 'mouse' && event.button !== 0) return;

            updateMousePos(event);
            raycaster.setFromCamera(mousePos, camera);

            // Get all meshes from simulation objects + targetBall
            const interactiveObjects = simulationObjects.map(obj => obj.mesh);
            if (targetBall) interactiveObjects.push(targetBall);

            const intersects = raycaster.intersectObjects(interactiveObjects);

            if (intersects.length > 0) {
                const hit = intersects[0];
                if (hit.object === targetBall) {
                    winLevel();
                    return;
                }

                // Find corresponding SimulationObject and its closest particle
                for (let obj of simulationObjects) {
                    if (obj.mesh === hit.object) {
                        let minDist = Infinity;
                        let targetPart = null;
                        for (let p of obj.particles) {
                            const d = p.position.distanceTo(hit.point);
                            if (d < minDist) {
                                minDist = d;
                                targetPart = p;
                            }
                        }
                        if (targetPart) {
                            isDragging = true;
                            draggedParticle = targetPart;
                            controls.enabled = false;
                            return;
                        }
                    }
                }
            }
        }

        function onPointerMove(event) {
            updateMousePos(event);
        }

        function onPointerUp() {
            isDragging = false;
            draggedParticle = null;
            if (activeMode !== 'grab') {
                controls.enabled = true;
            }
        }

        function updateMousePos(event) {
            mousePos.x = (event.clientX / window.innerWidth) * 2 - 1;
            mousePos.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function simulate() {
            forceGravity.set(0, -GRAVITY * MASS, 0);

            for (let obj of simulationObjects) {
                for (let p of obj.particles) {
                    p.addForce(forceGravity);
                    p.integrate(TIMESTEP * TIMESTEP);
                }
            }

            if (isDragging && draggedParticle) {
                raycaster.setFromCamera(mousePos, camera);
                const dragDist = draggedParticle.position.distanceTo(camera.position);
                const rayPoint = new THREE.Vector3();
                raycaster.ray.at(dragDist, rayPoint);
                draggedParticle.position.copy(rayPoint);
                draggedParticle.previous.copy(rayPoint);
            }

            const iterations = 8; 
            for (let i = 0; i < iterations; i++) {
                for (let obj of simulationObjects) {
                    for (let constraint of obj.constraints) {
                        constraint.satisfy();
                    }
                }
            }

            for (let obj of simulationObjects) {
                for (let p of obj.particles) {
                    // Floor
                    if (p.position.y < -100) {
                        p.position.y = -100;
                        p.previous.y = p.position.y;
                    }
                    // Ceiling
                    if (p.position.y > 1100) {
                        p.position.y = 1100;
                        p.previous.y = p.position.y;
                    }
                    // Walls X
                    if (p.position.x < -600) {
                        p.position.x = -600;
                        p.previous.x = p.position.x;
                    }
                    if (p.position.x > 600) {
                        p.position.x = 600;
                        p.previous.x = p.position.x;
                    }
                    // Walls Z
                    if (p.position.z < -600) {
                        p.position.z = -600;
                        p.previous.z = p.position.z;
                    }
                    if (p.position.z > 600) {
                        p.position.z = 600;
                        p.previous.z = p.position.z;
                    }
                }
            }
        }

        function winLevel() {
            const overlay = document.getElementById('victory-overlay');
            overlay.style.display = 'block';
            setTimeout(() => {
                overlay.style.display = 'none';
                currentLevel++;
                loadLevel(currentLevel);
            }, 2000);
        }

        function animate() {
            requestAnimationFrame(animate);
            simulate();

            for (let obj of simulationObjects) {
                obj.updateMesh();
            }

            controls.update();
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>
